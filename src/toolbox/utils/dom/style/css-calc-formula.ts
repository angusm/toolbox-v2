import {Variable, VariableSymbol} from "../../math/algebra/variable";
import {IMeasurableInstance} from "../../math/interfaces/measurable";
import {ICssStyleValueInstance} from "./interfaces/css-style-value";
import {DynamicDefaultMap} from "../../map/dynamic-default";
import {zip} from "../../array/zip";
import {Formula, FormulaPiece} from "../../math/algebra/formula";
import {contains} from "../../array/contains";
import {Add, Subtract} from "../../math/algebra/operation";
import {ErrorService} from "../../error/service";

const CSS_CALC_FORMULA_ALLOWED_UNITS = [
  'px',
  '%',
  'vh',
  'vw',
  'vmin',
  'vmax',
  'em',
  'rem'
];

class CssCalcFormula implements IMeasurableInstance, ICssStyleValueInstance {
  ['constructor']: typeof CssCalcFormula;
  protected values_: number[];

  constructor(...values: number[]) {
    this.values_ = values;
  }

  public static fromVariables(...values: Variable[]) {
    const mappedValues: DynamicDefaultMap<VariableSymbol, number> =
      new DynamicDefaultMap<VariableSymbol, number>(
        CssCalcFormula.mapValuesBySymbol_(...values),
        Map,
        () => 0);
    return new CssCalcFormula(
      ...CSS_CALC_FORMULA_ALLOWED_UNITS
        .map((allowedUnit) => mappedValues.get(allowedUnit)));
  }

  private static mapValuesBySymbol_(...values: Variable[]): [string, number][] {
    return values
      .map<[VariableSymbol, number]>((v) => [v.symbol, v.numericValue]);
  }

  public static fromNumbers(...values: number[]): CssCalcFormula {
    return new CssCalcFormula(...values);
  }

  public static fromStyleString(styleString: string): CssCalcFormula {
    const formula: string =
      styleString.slice(0, 4) === 'calc' ?
        styleString.slice(5, -1) :
        styleString;
    const formulaPieces = Formula.fromString(formula).getPieces();
    const addOnlyFormula: Array<Variable|typeof Add> = [];

    for (let i = formulaPieces.length - 1; i >= 0; i--) {
      const value = formulaPieces[i];
      if (value === Subtract) {
        addOnlyFormula[i] = Add;
        addOnlyFormula[i+1] = (<Variable>addOnlyFormula[i+1]).invert();
      } else if (!(value instanceof Variable) && value !== Add) {
        ErrorService.throw(
          'CssCalcFormula currently only supports Add/Subtract');
      } else {
        addOnlyFormula[i] = value;
      }
    }

    const variables: FormulaPiece[] =
      addOnlyFormula
        .filter(
          (value) => {
            return contains(
              CSS_CALC_FORMULA_ALLOWED_UNITS, (<Variable>value).symbol);
          })
        .filter((value) => value instanceof Variable);
    const orderedVariables: Variable[] =
      CSS_CALC_FORMULA_ALLOWED_UNITS.map(
        (allowedUnit) => {
          const matchingVariable =
            <Variable>(
              variables
                .find(
                  (variable) => (<Variable>variable).symbol === allowedUnit));
          return matchingVariable || new Variable(0, allowedUnit);
        });
    const values: number[] =
      orderedVariables.map((variable) => variable.numericValue);
    return new CssCalcFormula(...values);
  }

  public toNumbers(): number[] {
    return this.values_.slice();
  }

  public toStyleString(): string {
    const values: string[] =
      zip<string|number>(this.values_, CSS_CALC_FORMULA_ALLOWED_UNITS)
        .filter(([value, unit]) => value !== 0)
        .map((pair) => pair.join(''));
    if (values.length === 0) {
      return `0px`;
    } else if (values.length === 1) {
      return values[0];
    } else {
      return `calc(${values.join(' + ')})`;
    }
  }
}

export {
  CssCalcFormula,
  CSS_CALC_FORMULA_ALLOWED_UNITS
}
